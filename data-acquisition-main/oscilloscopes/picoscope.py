# coding=utf-8


from ctypes import *
from time import sleep
from picosdk.ps5000a import ps5000a as ps
from picosdk.functions import adc2mV, assert_pico_ok
import struct
import logging

# Link with the C API
PS5000A_TIME_UNITS = {"fs": 0, "ps": 1, "ns": 2, "us": 3, "ms": 4, "s": 5}
TIME_UNITS_IN_SECONDS = [1e-15, 1e-12, 1e-9, 1e-6, 1e-3, 1]
TIME_UNIT = PS5000A_TIME_UNITS["ps"]
PS5000A_CHANNEL = {"A": 0, "B": 1, "C": 2, "D": 3, "AUX": 4}
COUPLING = ps.PS5000A_COUPLING['PS5000A_DC']  # DC50
VRANGE = ps.PS5000A_RANGE['PS5000A_100MV']  # 100mV
ENABLE = 1
OFFSET = 0
BDWL = 0
AUTO_STOP = 0
DOWNSAMPLE_RATIO_MODE = 0  # None
DOWNSAMPLE_RATIO = 1
G_TRIGGER = False  # Global trigger enable flag
G_TRIGGERED = False  # Global triggered flag

logger = logging.getLogger("anon-sca")  # Centralized log

def pico_init(handle):
    serial = None  # Replace with your device's serial number if needed
    
    print("Handle: ", handle.value)
    ret = ps.ps5000aOpenUnit(byref(handle), None, ps.DEFAULT_RESOLUTION)
    print("Handle: ", handle.value)
    print("Open: ", ret)
    assert_pico_ok(ret)
    for channel in range(4):
        ret = ps.ps5000aSetChannel(handle, channel, ENABLE, COUPLING, VRANGE, OFFSET)
        print("SetChannel: ", ret)
        assert_pico_ok(ret)

def pico_close(handle):
    ret = ps.ps5000aStop(handle)
    print("Stop: ", ret)
    assert_pico_ok(ret)
    ret = ps.ps5000aCloseUnit(handle)
    print("Close: ", ret)
    assert_pico_ok(ret)

@CFUNCTYPE(None, c_int16, c_int32, c_uint32, c_int16, c_uint32, c_int16, c_int16, c_void_p)
def callback(handle, nSamples, startIndex, overflow, triggerAt, triggered, autoStop, pParameter):
    global dataFileHandler, totalNumberOfSamples, buff, G_TRIGGERED, G_TRIGGER
    if not G_TRIGGER or (G_TRIGGER and G_TRIGGERED) or triggered:
        if G_TRIGGER and not G_TRIGGERED:
            logger.debug('Triggered!')
            G_TRIGGERED = True
        for i in range(nSamples):
            s = buff[i + startIndex]
            dataFileHandler.write(struct.pack('h', s))  # Thread unsafe
        totalNumberOfSamples += nSamples
        logger.debug('Got %i samples at index %i.' % (nSamples, startIndex))

def pico_streaming(handle, channel, duration, sampleRate, bufferLth, dataFile, verbose, TriggerChannel=None, maxPreTriggerSamples=0):
    global dataFileHandler, G_TRIGGER
    dataFileHandler = open(dataFile, mode='wb')
    global buff
    buff = (c_int16 * bufferLth)()
    global totalNumberOfSamples
    totalNumberOfSamples = 0
    logging.basicConfig(level=logging.DEBUG if verbose else logging.INFO)
    
    channel = PS5000A_CHANNEL[channel]
    pParameter = c_void_p()
    sampleInterval = c_uint32(int(TIME_UNITS_IN_SECONDS[TIME_UNIT] * sampleRate))
    
    ret = ps.ps5000aSetChannel(handle, channel, ENABLE, COUPLING, VRANGE, OFFSET)
    print("SetChannel: ", ret)
    assert_pico_ok(ret)
    
    if TriggerChannel:
        logger.debug('Starting trigger')
        G_TRIGGER = True
        trigger_channel_index = PS5000A_CHANNEL.get(TriggerChannel, 4)  # Default to AUX if not found
        ret = ps.ps5000aSetSimpleTrigger(handle, ENABLE, trigger_channel_index, 0x3f00, 2, 0, 0)  # Adjust trigger settings as needed
        print("SetTrigger: ", ret)
        assert_pico_ok(ret)
    
    ret = ps.ps5000aSetDataBuffer(handle, channel, byref(buff), bufferLth, DOWNSAMPLE_RATIO_MODE)
    print("SetDataBuffer: ", ret)
    assert_pico_ok(ret)
    
    ret = ps.ps5000aRunStreaming(handle, byref(sampleInterval), TIME_UNIT, maxPreTriggerSamples, bufferLth, AUTO_STOP, DOWNSAMPLE_RATIO, DOWNSAMPLE_RATIO_MODE, bufferLth)
    print("RunStreaming: ", ret)
    assert_pico_ok(ret)
    
    dataLth = duration * sampleRate
    while totalNumberOfSamples < dataLth:
        ret = ps.ps5000aGetStreamingLatestValues(handle, callback, byref(pParameter))
        print("GetStreamingLatestValues: ", ret)
    
    dataFileHandler.close()

def pico_block(handle, channel, dataFile, nbSamples, timebase, verbose, TriggerChannel=None, noOfPreTriggerSamples=0):
    dataFileHandler = open(dataFile, mode='wb')
    logging.basicConfig(level=logging.DEBUG if verbose else logging.INFO)
    
    channel = PS5000A_CHANNEL[channel]
    print("Handle after opening: ", handle.value)
    
    # Set the channel
    ret = ps.ps5000aSetChannel(handle, channel, ENABLE, COUPLING, VRANGE, OFFSET)
    print("SetChannel: ", ret)
    assert_pico_ok(ret)
    
    # Set the trigger if required
    if TriggerChannel:
        logger.debug('Starting trigger')
        trigger_channel_index = PS5000A_CHANNEL.get(TriggerChannel, 4)  # Default to AUX if not found
        ret = ps.ps5000aSetSimpleTrigger(handle, ENABLE, trigger_channel_index, 0x3f00, 2, 0, 0)  # Adjust trigger settings as needed
        print("SetTrigger: ", ret)
        assert_pico_ok(ret)
    
    # Calculate frequency
    if timebase < 5:
        freq = 5e9 / 2**timebase
    else:
        freq = 156250000 / (timebase - 4)
    
    # Get timebase
    timeIntervalns = c_float()
    maxSamples = c_int32()
    ret = ps.ps5000aGetTimebase2(handle, timebase, nbSamples, byref(timeIntervalns), byref(maxSamples), 0)
    print("GetTimebase: ", ret)
    assert_pico_ok(ret)
    
    logger.debug("Max number of samples: {:d}".format(maxSamples.value))
    
    if nbSamples == 0:
        nbSamples = maxSamples.value
    
    logger.debug("Sample rate: {}Mss".format(int(freq / 1e6)))
    logger.debug("Number of samples: {:d}".format(nbSamples))
    logger.debug("Capture length: {:.3f}us".format(timeIntervalns.value * nbSamples / 1e3))
    
    # Run block mode
    noOfPostTriggerSamples = nbSamples - noOfPreTriggerSamples
    ret = ps.ps5000aRunBlock(handle, noOfPreTriggerSamples, noOfPostTriggerSamples, timebase, None, 0, None, None)
    print("RunBlock: ", ret)
    assert_pico_ok(ret)
    
    # Add initial sleep
    ready = c_int16(0)
    check = c_int16(1)
    sleep(1)  # Increase initial sleep time to give more time for preparation
    
    # Wait for the device to be ready
    while ready.value == 1:
        ret = ps.ps5000aIsReady(handle, byref(ready))
        print("IsReady: ", ret, "Ready value: ", ready.value)
        if ready.value == 0:
            sleep(0.1)  # Add a short delay to prevent tight looping
    
    # Get data
    buff = (c_int16 * nbSamples)()
    ret = ps.ps5000aSetDataBuffer(handle, channel, byref(buff), nbSamples, 0, DOWNSAMPLE_RATIO_MODE)
    print("SetDataBuffer: ", ret)
    assert_pico_ok(ret)
    
    c_nbSamples = c_int32(nbSamples)
    ret = ps.ps5000aGetValues(handle, 0, byref(c_nbSamples), 1, 0, 0, None) 
    print("GetValues: ", ret)
    assert_pico_ok(ret)
    
    logger.debug("Captured {:d} samples".format(c_nbSamples.value))
    
    for i in range(c_nbSamples.value):
        dataFileHandler.write(struct.pack('h', buff[i]))
    
    dataFileHandler.close()
