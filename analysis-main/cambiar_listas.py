# import numpy as np

# # Cargar el archivo .npy
# data = np.load('files_lists_tagmaps=executable_classification.npy', allow_pickle=True)

# # Ver el contenido original
# print("Contenido original:")

# # Definir una función para modificar los nombres de archivo
# def modificar_nombre(archivo):
#     # Aquí puedes definir cómo deseas modificar el nombre del archivo
#     return archivo.replace('gonnacry_Virtualize2', 'modificado_gonnacry_Virtualize2')

# # Aplicar la modificación a todos los nombres de archivos en la matriz
# for lista in data:
#     for i in range(len(lista)):
#         lista[i] = modificar_nombre(lista[i])

# # Guardar los datos modificados en un nuevo archivo .npy
# np.save('ruta_al_nuevo_archivo.npy', data)

# # Verificar el contenido del nuevo archivo
# nuevo_data = np.load('ruta_al_nuevo_archivo.npy', allow_pickle=True)
# print("Contenido modificado:")




# import numpy as np
# import os

# # Cargar el archivo .npy
# data = np.load('files_lists_tagmaps=executable_classification.npy', allow_pickle=True)

# # Ver el contenido original
# print("Contenido original:")

# # Ruta a la carpeta con los nuevos nombres de archivo
# carpeta_nuevos_archivos = '/ahma-hub/data-acquisition-main/bashlite-2.43s-2Mss'


# # Obtener la lista de nuevos nombres de archivo
# nuevos_nombres = [f for f in os.listdir(carpeta_nuevos_archivos) if f.endswith('.dat')]

# # Asegurarse de que la cantidad de nuevos nombres coincide con los que hay que reemplazar
# total_nombres_actuales = sum(len(lista) for lista in data)

# if len(nuevos_nombres) < total_nombres_actuales:
#     print(len(nuevos_nombres))
#     print(total_nombres_actuales)
#     raise ValueError("No hay suficientes nuevos nombres de archivo para reemplazar todos los existentes")

# # Crear un iterador para los nuevos nombres de archivo
# nuevo_nombre_iter = iter(nuevos_nombres)

# # Realizar la sustitución en cada lista de la matriz
# for lista in data:
#     for i in range(len(lista)):
#         # Obtener la parte del nombre de archivo antes del //
#         prefijo = lista[i].split('//')[0] + '//'
#         # Obtener el siguiente nuevo nombre de archivo del iterador
#         nuevo_nombre = next(nuevo_nombre_iter)
#         # Sustituir la parte del nombre de archivo después del //
#         lista[i] = prefijo + nuevo_nombre

# # Guardar los datos modificados en un nuevo archivo .npy
# np.save('ruta_al_nuevo_archivo.npy', data)

# # Verificar el contenido del nuevo archivo
# nuevo_data = np.load('ruta_al_nuevo_archivo.npy', allow_pickle=True)
# print("Contenido modificado:", nuevo_data)
import numpy as np
import os
import re

# Cargar el archivo .npy
data = np.load('files_lists_tagmaps=executable_classification.npy', allow_pickle=True)

# Ver el contenido original
print("Tipo de dato:", type(data))
print("Forma de la matriz:", data.shape)

# Ruta a la carpeta con los nuevos nombres de archivo
carpeta_nuevos_archivos = '/ahma-hub/data-acquisition-main/bashlite-2.43s-2Mss'

# Obtener la lista de nuevos nombres de archivo
nuevos_nombres = [f for f in os.listdir(carpeta_nuevos_archivos) if f.endswith('.dat')]

# Verificar si hay nuevos nombres de archivo disponibles
if not nuevos_nombres:
    raise ValueError("No hay nuevos nombres de archivo disponibles en la carpeta especificada.")

# Crear un iterador para los nuevos nombres de archivo
nuevo_nombre_iter = iter(nuevos_nombres)

# Lista para almacenar las nuevas listas de nombres de archivo
nueva_data = []

# Realizar la sustitución y eliminación en cada lista de la matriz
for lista in data:
    nueva_lista = []
    for item in lista:
        try:
            # Obtener el siguiente nuevo nombre de archivo del iterador
            nuevo_nombre = next(nuevo_nombre_iter)
            # Obtener la parte del nombre de archivo antes del //
            prefijo = item.split('//')[0] + '//'
            # Sustituir la parte del nombre de archivo después del //
            nuevo_nombre_completo = prefijo + nuevo_nombre
            nueva_lista.append(nuevo_nombre_completo)
        except StopIteration:
            # Si se acaban los nuevos nombres, dejar de agregar elementos
            break
    nueva_data.append(nueva_lista)

# Eliminar las listas vacías de nueva_data
if nueva_data:
    nueva_data = [lista for lista in nueva_data if lista]

# Dividir los elementos entre las tres primeras listas
todos_los_elementos = [item for sublista in nueva_data for item in sublista]

# Calcular la cantidad de elementos para cada una de las tres primeras listas
mitad = len(todos_los_elementos) // 2
segunda_parte = todos_los_elementos[mitad:]
tercera_parte = len(segunda_parte) // 3

# Asignar los elementos a las tres primeras listas
nueva_data = []
nueva_data.append(todos_los_elementos[:mitad])
nueva_data.append(segunda_parte[:2 * tercera_parte])
nueva_data.append(segunda_parte[2 * tercera_parte:])

# Ruta al archivo de texto que contiene los nombres
archivo_nombres = 'nombres_extraidos.txt'

# Leer los nombres del archivo de texto
with open(archivo_nombres, 'r') as file:
    nombres = file.read().splitlines()

# Dividir los nombres entre las tres listas siguientes
mitad_nombres = len(nombres) // 2
segunda_parte_nombres = nombres[mitad_nombres:]
tercera_parte_nombres = len(segunda_parte_nombres) // 3

# Asignar los nombres a las listas correspondientes
nueva_data.append(nombres[:mitad_nombres])
nueva_data.append(segunda_parte_nombres[:2 * tercera_parte_nombres])
nueva_data.append(segunda_parte_nombres[2 * tercera_parte_nombres:])

# Verificar el contenido de nueva_data_distribuida
print(nueva_data)

# Convertir la lista de nuevas listas a un arreglo de numpy
nueva_data_array = np.array(nueva_data, dtype=object)

# Guardar los datos modificados en un nuevo archivo .npy
np.save('ruta_al_nuevo_archivo.npy', nueva_data_array)

# Verificar el contenido del nuevo archivo
nuevo_data = np.load('ruta_al_nuevo_archivo.npy', allow_pickle=True)
print("Contenido modificado:")
print(nuevo_data)

# Crear y abrir el archivo de texto para guardar el resultado
with open('resultado.txt', 'w') as archivo:
    # Guardar el tipo de dato
    archivo.write("Tipo de dato: " + str(type(data)) + "\n\n")
    
    # Guardar el contenido del archivo .npy
    archivo.write("Contenido del archivo:\n")
    archivo.write(str(nuevo_data) + "\n\n")
    
    # Guardar el tamaño de cada lista
    archivo.write("Tamaño de cada lista:\n")
    for i, lista in enumerate(nuevo_data):
        archivo.write(f"Tamaño de la lista {i + 1}: {len(lista)}\n")
    
    print(len(nuevo_data))
